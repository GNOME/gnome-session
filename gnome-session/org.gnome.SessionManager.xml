<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">

<!--
  org.gnome.SessionManager:
  @short_description: The Manager
-->
<node>
  <interface name="org.gnome.SessionManager">
    <annotation name="org.gtk.GDBus.C.Name" value="ExportedManager"/>

    <!-- Initialization phase interfaces -->

    <!--
      Setenv:
      @variable: The variable name
      @value: The variable value

      Adds the variable name to the application launch environment with the
      specified value. May only be used during the Session Manager
      initialization phase.
    -->
    <method name="Setenv">
      <arg name="variable" type="s" direction="in"/>
      <arg name="value" type="s" direction="in"/>
    </method>

    <!--
      GetLocale:
      @category: The locale category
      @value: The value

      Reads the current state of the specific locale category.
    -->
    <method name="GetLocale">
      <arg name="category" type="i" direction="in"/>
      <arg name="value" type="s" direction="out"/>
    </method>

    <!--
      InitializationError:
      @message: The error message
      @fatal: Whether the error should be treated as fatal

      May be used by applications launched during the Session Manager
      initialization phase to indicate there was a problem.
    -->
    <method name="InitializationError">
      <arg name="message" type="s" direction="in"/>
      <arg name="fatal" type="b" direction="in"/>
    </method>

    <!--
      Initialized:

      Run from systemd to signal that gnome-session-initialized.target has
      been reached.
    -->
    <method name="Initialized"/>

    <!-- Running phase interfaces -->

    <!--
      RegisterClient:
      @app_id: The application identifier
      @ignored: An ignored parameter, which exists only to make this API backwards-compatible with older versions of GNOME
      @client_id: The object path of the newly registered client

      Register the caller as a Session Management client.
    -->
    <method name="RegisterClient">
      <arg type="s" name="app_id" direction="in"/>
      <arg type="s" name="ignored" direction="in"/>
      <arg type="o" name="client_id" direction="out"/>
    </method>

    <!--
      UnregisterClient:
      @client_id: The object path of the client

      Unregister the specified client from Session Management.
    -->
    <method name="UnregisterClient">
      <arg type="o" name="client_id" direction="in"/>
    </method>

    <!--
      RegisterRestore:
      @app_id: The application identifier
      @dbus_name: The app's dbus unique name, for crash monitoring
      @reason: The app's restore reason, see below
      @instance_id: A stable ID for this instance of this app
      @cleanup_ids: A list of instance IDs the session manager wishes to discard

      Register the specified app for session save/restore functionality. Apps
      that register here will be relaunched on next login, and can restore their
      saved state.

      The restore @reason communicates to an app how much state it should restore.
      See the following table:

      <itemizedlist>
        <listitem><para>
          <emphasis>0</emphasis>:
          The app shouldn't restore any state
        </para></listitem>
        <listitem><para>
          <emphasis>1</emphasis>:
          This is a normal app launch. The app should restore as much state
          as is reasonable. For instance: an app like GNOME Calculator may
          restore the last-used mode (Basic/Advanced/Programmer/...) but won't
          restore the history.
        </para></listitem>
        <listitem><para>
          <emphasis>2</emphasis>:
          This is an app restore after a crash. The app should restore as much
          state as is possible, but should be careful about causing the crash
          again. For instance, an app like GNOME Web might immediately load all
          of its tabs after a normal restore, but only show the "This page may
          have caused Web to crash" page in each tab after a crash restore. This
          is also returned if the entire session crashed
        </para></listitem>
        <listitem><para>
          <emphasis>3</emphasis>:
          This is a normal app restore. The app was shut down due to logout or
          some other reason, and the session was cleanly ended. The app should
          restore as much state as is possible.
        </para></listitem>
      </itemizedlist>

      The @instance_id incorporates a string that identifies this session. This
      means that the app can safely assume that there will never be an instance
      ID collision with other session managers from other desktop environments,
      or even other sessions managed by gnome-session.

      The instance IDs returned in @cleanup_ids will never be reused, and the
      app should delete any data associated with these IDs from disk. When
      complete, the app should notify the session manager via
      #org.gnome.SessionManager.DeletedInstanceIds()

      This is a private interface between gnome-session and xdg-desktop-portal.
      Apps should talk to the portal directly for this functionality.
    -->
    <method name="RegisterRestore">
      <arg type="s" name="app_id" direction="in"/>
      <arg type="s" name="dbus_name" direction="in"/>
      <arg type="u" name="reason" direction="out"/>
      <arg type="s" name="instance_id" direction="out"/>
      <arg type="as" name="cleanup_ids" direction="out"/>
    </method>

    <!--
      DeletedInstanceIds:
      @app_id: The application identifier
      @ids: List of instance IDs the application deleted

      Used to notify the session manager that the app has successfully deleted
      the instance IDs, and that the manager is now free to forget them for good.

      This is a private interface between gnome-session and xdg-desktop-portal.
      Apps should talk to the portal directly for this functionality.
    -->
    <method name="DeletedInstanceIds">
      <arg type="s" name="app_id" direction="in"/>
      <arg type="as" name="ids" direction="in"/>
    </method>

    <!--
      UnregisterRestore:
      @app_id: The application identifier
      @instance_id: The application's instance_id

      Un-registers the app from the session save/restore functionality. This
      should be called whenever the app exits cleanly.

      This is a private interface between gnome-session and xdg-desktop-portal.
      Apps should talk to the portal directly for this functionality.
    -->
    <method name="UnregisterRestore">
      <arg type="s" name="app_id" direction="in"/>
      <arg type="s" name="instance_id" direction="in"/>
    </method>

    <!--
      Inhibit:
      @app_id: The application identifier, optional
      @ignored: An ignored parameter, which exists only to make this API backwards-compatible with older versions of GNOME
      @reason: The reason for the inhibit
      @flags: Flags that specify what should be inhibited
      @inhibit_cookie: The cookie

      Applications should invoke this method when they begin an operation that
      should not be interrupted, such as creating a CD or DVD. The types of actions
      that may be blocked are specified by the flags parameter. When the application
      completes the operation it should call #org.gnome.SessionManager.Uninhibit()
      or disconnect from the session bus.

      Applications should not expect that they will always be able to block the
      action. In most cases, users will be given the option to force the action
      to take place. If @app_id is not specified, the user might not be informed
      of this inhibitor when prompted to force the action.

      The @flags parameter must include at least one of the following flags,
      bitwise or'ed together:

      <itemizedlist>
        <listitem><para>
          <emphasis>1</emphasis>:
          Inhibit logging out
        </para></listitem>
        <listitem><para>
          <emphasis>2</emphasis>:
          Inhibit user switching
        </para></listitem>
        <listitem><para>
          <emphasis>4</emphasis>:
          Inhibit suspending the session or computer
        </para></listitem>
        <listitem><para>
          <emphasis>8</emphasis>:
          Inhibit the session being marked as idle
        </para></listitem>
        <listitem><para>
          <emphasis>16</emphasis>:
          Inhibit auto-mounting removable media for the session
        </para></listitem>
      </itemizedlist>

      The returned cookie is used to uniquely identify this request. It should
      be used as an argument to #org.gnome.SessionManager.Uninhibit()
      in order to remove the request.
    -->
    <method name="Inhibit">
      <arg type="s" name="app_id" direction="in"/>
      <arg type="u" name="ignored" direction="in"/>
      <arg type="s" name="reason" direction="in"/>
      <arg type="u" name="flags" direction="in"/>
      <arg type="u" name="inhibit_cookie" direction="out"/>
    </method>

    <!--
      Uninhibit:
      @inhibit_cookie: The cookie

      Cancel a previous call to #org.gnome.SessionManager.Inhibit(),
      identified by the cookie.
    -->
    <method name="Uninhibit">
      <arg type="u" name="inhibit_cookie" direction="in"/>
    </method>

    <!--
      IsInhibited:
      @flags: Flags that specify what should be inhibited
      @is_inhibited: TRUE if any of the operations in @flags are inhibited

      Determine if operation(s) specified by the flags are currently inhibited.
      Flags are same as those accepted by the #org.gnome.SessionManager.Inhibit()
      method.
    -->
    <method name="IsInhibited">
      <arg type="u" name="flags" direction="in"/>
      <arg type="b" name="is_inhibited" direction="out"/>
    </method>

    <!--
      GetInhibitors:
      @inhibitors: an array of inhibitor IDs

      This gets a list of all the inhibitors that are currently known to the
      session manager. Each inhibitor ID is a D-Bus object path to the object
      that implements the <link linkend='gdbus-org.gnome.SessionManager.Inhibitor'>
      Inhibitor interface</link>
    -->
    <method name="GetInhibitors">
      <arg name="inhibitors" direction="out" type="ao"/>
    </method>

    <!--
      Shutdown:

      Request a shutdown dialog.
    -->
    <method name="Shutdown"/>

    <!--
      Reboot:

      Request a reboot dialog.
    -->
    <method name="Reboot"/>

    <!--
      CanShutdown
      @is_available: True if shutdown is available to the user, false otherwise

      Allows the caller to determine whether or not it's okay to show a shutdown
      option in the UI
    -->
    <method name="CanShutdown">
      <arg name="is_available" direction="out" type="b"/>
    </method>

    <!--
      SetRebootToFirmwareSetup:
      @enable: Whether we should reboot into setup

      Allows the caller to indicate to the system's firmware to boot into
      setup mode
    -->
    <method name="SetRebootToFirmwareSetup">
      <arg name="enable" direction="in" type="b"/>
    </method>

    <!--
      CanRebootToFirmwareSetup:
      @is_available: True if boot into setup mode is available to the user, false otherwise

      Allows the caller to determine whether or not it's okay to show a reboot
      to firmware option in the UI
    -->
    <method name="CanRebootToFirmwareSetup">
      <arg name="is_available" direction="out" type="b"/>
    </method>

    <!--
      Logout:
      @mode: The type of logout that is being requested

      Request a log out dialog.

      You may pass the following flags into @mode, and they can be bitwise
      or'ed together:

      <itemizedlist>
        <listitem><para><emphasis>0</emphasis>: Normal</para></listitem>
        <listitem><para>
          <emphasis>1</emphasis>:
          No confirmation interface should be shown.
        </para></listitem>
        <listitem><para>
          <emphasis>2</emphasis>:
          Forcefully logout. No confirmation will be shown and any inhibitors
          will be ignored.
        </para></listitem>
      </itemizedlist>
    -->
    <method name="Logout">
      <arg name="mode" type="u" direction="in"/>
    </method>

    <!--
      IsSessionRunning:
      @running: True if the session is running, false otherwise.

      Allows the caller to determine whether the session is running or not.
      Returns false if the session is initializing, or shutting down.
    -->
    <method name="IsSessionRunning">
      <arg name="running" direction="out" type="b"/>
    </method>

    <!-- Signals -->

    <!--
      ClientAdded:
      @id: The object path for the added client

      Emitted when a client has been added to the session manager.
    -->
    <signal name="ClientAdded">
      <arg name="id" type="o"/>
    </signal>

    <!--
      ClientRemoved:
      @id: The object path for the removed client

      Emitted when a client has been removed from the session manager.
    -->
    <signal name="ClientRemoved">
      <arg name="id" type="o"/>
    </signal>

    <!--
      InhibitorAdded:
      @id: The object path for the added inhibitor

      Emitted when an inhibitor has been added to the session manager.
    -->
    <signal name="InhibitorAdded">
      <arg name="id" type="o"/>
    </signal>

    <!--
      InhibitorRemoved:
      @id: The object path for the removed inhibitor

      Emitted when an inhibitor has been removed from the session manager.
    -->
    <signal name="InhibitorRemoved">
      <arg name="id" type="o"/>
    </signal>

    <!--
      SessionRunning:

      Emitted when the session is done initializing.
    -->
    <signal name="SessionRunning"/>

    <!--
      SessionOver:

      Emitted when the session is about to end.
    -->
    <signal name="SessionOver"/>

    <!-- Properties -->

    <!--
      SessionName: The name of the session that has been loaded.
    -->
    <property name="SessionName" type="s" access="read"/>

    <!--
      Renderer:

      Starting in GNOME 49, this property always returns an empty string.
      You should instead use the <literal>GPUs</literal> property on the
      <ulink url="https://gitlab.freedesktop.org/hadess/switcheroo-control/-/blob/master/src/net.hadess.SwitcherooControl.xml">
      net.hadess.SwitcherooControl</ulink> service instead.
    -->
    <property name="Renderer" type="s" access="read">
      <!-- FIXME: Adjust the switcheroo-control link once this is fixed usptream:
           https://gitlab.freedesktop.org/hadess/switcheroo-control/-/issues/36 -->
      <annotation name="org.freedesktop.DBus.Deprecated" value="true"/>
    </property>

    <!--
      SessionIsActive:

      If true, the session is currently in the foreground and available for
      user input.
    -->
    <property name="SessionIsActive" type="b" access="read"/>

    <!--
      InhibitedActions:

      A bitmask of flags to indicate which actions are inhibited. See
      #org.gnome.SessionManager.Inhibit() for a list of possible values.
    -->
    <property name="InhibitedActions" type="u" access="read"/>

  </interface>
</node>
